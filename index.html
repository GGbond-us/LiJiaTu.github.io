<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js å¡”ç½— - è™šç©ºå¬å”¤ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Microsoft YaHei', sans-serif; color: #fff; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        /* é¡¶éƒ¨æ§åˆ¶ */
        .hud-panel { position: absolute; pointer-events: auto; }
        #controls { top: 20px; left: 20px; display: flex; gap: 10px; align-items: center; }
        button { 
            background: rgba(0,0,0,0.6); color: #fff; border: 1px solid #666; 
            padding: 6px 15px; cursor: pointer; transition: all 0.3s; border-radius: 4px;
        }
        button:hover { background: #fff; color: #000; box-shadow: 0 0 10px #fff; }
        
        #video-preview { width: 120px; height: 90px; transform: scaleX(-1); border: 1px solid #333; display: none; margin-top: 10px; opacity: 0.8; }
        
        /* ä¸­é—´å¼•å¯¼æ–‡å­— */
        #guide-text { 
            position: absolute; top: 20%; width: 100%; text-align: center; 
            font-size: 28px; font-weight: 300; text-shadow: 0 0 15px rgba(255,255,255,0.8); letter-spacing: 4px;
            transition: all 0.5s;
        }
        #sub-guide {
            position: absolute; top: 26%; width: 100%; text-align: center;
            font-size: 14px; color: #aaa; letter-spacing: 2px;
        }
        
        /* å•å¼ å¡ç‰Œå±•ç¤ºä¿¡æ¯ (ä¸´æ—¶) */
        #single-card-info {
            position: absolute; top: 65%; width: 100%; text-align: center;
            opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }
        #single-card-info h2 { font-size: 24px; margin-bottom: 5px; color: #ffd700; }
        #single-card-info p { font-size: 16px; color: #ccc; }

        /* æœ€ç»ˆæ€»ç»“é¢æ¿ */
        #final-panel {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 40%;
            background: linear-gradient(to top, rgba(0,0,0,1) 20%, rgba(0,0,0,0.6));
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 1s;
        }
        #final-panel.active { opacity: 1; pointer-events: auto; }
        
        .summary-box { 
            width: 80%; max-width: 800px; text-align: center; 
            background: rgba(20,20,20,0.8); padding: 20px; border: 1px solid #444; border-radius: 8px;
        }
        .summary-title { font-size: 20px; margin-bottom: 15px; color: #fff; border-bottom: 1px solid #333; padding-bottom: 10px;}
        .summary-content { font-size: 14px; line-height: 1.8; color: #ddd; text-align: left; }
        .action-hint { margin-top: 15px; font-size: 12px; color: #888; animation: pulse 2s infinite; }

        @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }
        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.2rem; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">è¿æ¥çµæ€§ç½‘ç»œä¸­...</div>

    <div id="ui-layer">
        <div id="controls" class="hud-panel">
            <button id="btn-mode-hand">ğŸ– æ‰‹åŠ¿æ¨¡å¼</button>
            <button id="btn-mode-mouse">ğŸ–±ï¸ é¼ æ ‡æ¨¡å¼</button>
            <div id="gesture-indicator" style="font-size:12px; color:#aaa; margin-top:5px;">ç­‰å¾…ä¸­...</div>
            <video id="video-preview" playsinline></video>
        </div>

        <div id="guide-text">ç¬¬ä¸€ç« ï¼šè¿‡å»</div>
        <div id="sub-guide">æ»‘åŠ¨é€‰æ‹© â€¢ å±…ä¸­ç¡®è®¤</div>

        <div id="single-card-info">
            <h2 id="single-name">Card Name</h2>
            <p id="single-desc">Meaning...</p>
            <div style="font-size:12px; color:#888; margin-top:10px;">ç‚¹å‡»æˆ–æ¡æ‹³ä»¥é“­è®°äºå¿ƒï¼Œä½¿å…¶æ¶ˆæ•£</div>
        </div>

        <div id="final-panel">
            <div class="summary-box">
                <div class="summary-title">å‘½è¿ä¸‰ç«  â€¢ å¯ç¤ºå½•</div>
                <div class="summary-content" id="final-summary-text">
                    <!-- JS ç”Ÿæˆæ€»ç»“ -->
                </div>
                <div class="action-hint">æ¡æ‹³ / ç‚¹å‡» ç»“æŸä»ªå¼</div>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

<script>
// ==========================================
// 0. æ•°æ®å®šä¹‰
// ==========================================
const FULL_DECK_DATA = [
    { id: 0, name: "æ„šè€…", url: "https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg", up: "æ–°çš„å¼€å§‹ã€å¤©çœŸã€è‡ªç”±ç²¾ç¥", rev: "é²è½ã€è½»ç‡ã€é£é™©" },
    { id: 1, name: "é­”æœ¯å¸ˆ", url: "https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg", up: "åˆ›é€ åŠ›ã€æŠ€èƒ½ã€æ„å¿—åŠ›", rev: "æ¬ºéª—ã€æ‰åè¢«åŸ‹æ²¡" },
    { id: 2, name: "å¥³ç¥­å¸", url: "https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg", up: "ç›´è§‰ã€æ½œæ„è¯†ã€ç¥ç§˜", rev: "ç§˜å¯†æ³„éœ²ã€å‹æŠ‘æƒ…æ„Ÿ" },
    { id: 3, name: "çš‡å", url: "https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg", up: "ä¸°é¥¶ã€æ¯æ€§ã€è‡ªç„¶", rev: "ä¾èµ–ã€åˆ›é€ åŠ›å—é˜»" },
    { id: 4, name: "çš‡å¸", url: "https://upload.wikimedia.org/wikipedia/commons/c/c3/RWS_Tarot_04_Emperor.jpg", up: "æƒå¨ã€ç»“æ„ã€ç¨³å›º", rev: "æš´æ”¿ã€åƒµåŒ–ã€å†·é…·" },
    { id: 5, name: "æ•™çš‡", url: "https://upload.wikimedia.org/wikipedia/commons/8/8d/RWS_Tarot_05_Hierophant.jpg", up: "ä¼ ç»Ÿã€ä¿¡ä»°ã€ç²¾ç¥æŒ‡å¼•", rev: "æŒ‘æˆ˜ä¼ ç»Ÿã€è™šä¼ª" },
    { id: 6, name: "æ‹äºº", url: "https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_06_Lovers.jpg", up: "çˆ±ã€å’Œè°ã€é€‰æ‹©", rev: "åˆ†ç¦»ã€ä¸å¹³è¡¡ã€å†²çª" },
    { id: 7, name: "æˆ˜è½¦", url: "https://upload.wikimedia.org/wikipedia/commons/9/9b/RWS_Tarot_07_Chariot.jpg", up: "æ§åˆ¶ã€æ„å¿—åŠ›ã€èƒœåˆ©", rev: "å¤±æ§ã€æ”»å‡»æ€§ã€å¤±è´¥" },
    { id: 8, name: "åŠ›é‡", url: "https://upload.wikimedia.org/wikipedia/commons/f/f5/RWS_Tarot_08_Strength.jpg", up: "åŠ›é‡ã€å‹‡æ°”ã€è€å¿ƒ", rev: "è½¯å¼±ã€è‡ªæˆ‘æ€€ç–‘" },
    { id: 9, name: "éšå£«", url: "https://upload.wikimedia.org/wikipedia/commons/4/4d/RWS_Tarot_09_Hermit.jpg", up: "å†…çœã€å­¤ç‹¬ã€æŒ‡å¼•", rev: "å­¤ç«‹ã€è¿·å¤±" },
    { id: 10, name: "å‘½è¿ä¹‹è½®", url: "https://upload.wikimedia.org/wikipedia/commons/3/3c/RWS_Tarot_10_Wheel_of_Fortune.jpg", up: "å¥½è¿ã€å› æœã€è½¬æŠ˜", rev: "å„è¿ã€æŠµæŠ—æ”¹å˜" },
    { id: 13, name: "æ­»ç¥", url: "https://upload.wikimedia.org/wikipedia/commons/d/d7/RWS_Tarot_13_Death.jpg", up: "ç»“æŸã€è½¬å˜ã€é‡ç”Ÿ", rev: "æŠ—æ‹’æ”¹å˜ã€åœæ»" },
    { id: 16, name: "é«˜å¡”", url: "https://upload.wikimedia.org/wikipedia/commons/5/53/RWS_Tarot_16_Tower.jpg", up: "å‰§å˜ã€ç¾éš¾ã€è§‰é†’", rev: "é¿å…ç¾éš¾ã€ææƒ§æ”¹å˜" },
    { id: 17, name: "æ˜Ÿæ˜Ÿ", url: "https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_17_Star.jpg", up: "å¸Œæœ›ã€ä¿¡å¿µã€çµæ„Ÿ", rev: "ç»æœ›ã€ç¼ºä¹ä¿¡å¿ƒ" },
    { id: 18, name: "æœˆäº®", url: "https://upload.wikimedia.org/wikipedia/commons/7/7f/RWS_Tarot_18_Moon.jpg", up: "å¹»è§‰ã€ææƒ§ã€æ½œæ„è¯†", rev: "é‡Šæ”¾ææƒ§ã€ä¸å¹¸" },
    { id: 19, name: "å¤ªé˜³", url: "https://upload.wikimedia.org/wikipedia/commons/1/17/RWS_Tarot_19_Sun.jpg", up: "å¿«ä¹ã€æˆåŠŸã€æ´»åŠ›", rev: "æ¶ˆæ²‰ã€æš‚æ—¶çš„æŒ«æŠ˜" },
    { id: 21, name: "ä¸–ç•Œ", url: "https://upload.wikimedia.org/wikipedia/commons/f/ff/RWS_Tarot_21_World.jpg", up: "å®Œæˆã€æ•´åˆã€æˆå°±", rev: "æœªå®Œæˆã€ç¼ºä¹é—­ç¯" }
];

const PHASE_TITLES = ["ç¬¬ä¸€ç« ï¼šè¿‡å» / æˆå› ", "ç¬¬äºŒç« ï¼šç°åœ¨ / ç°çŠ¶", "ç¬¬ä¸‰ç« ï¼šæœªæ¥ / å‘å±•"];
const PHASE_DESC = [
    "ä»£è¡¨å·²ç»å‘ç”Ÿä½†ä»åœ¨å½±å“å½“ä¸‹çš„èƒ½é‡",
    "ä»£è¡¨ä½ ç›®å‰æ­£åœ¨ç»å†çš„æ ¸å¿ƒè¯¾é¢˜",
    "ä»£è¡¨å¦‚æœä¿æŒå½“å‰è½¨è¿¹ï¼Œæœ€å¯èƒ½å‰å¾€çš„æ–¹å‘"
];

const CONFIG = {
    cardWidth: 2.2, cardHeight: 3.8, cardRadius: 0.1, cardSpacing: 2.8,
    scrollSpeed: 4.0, friction: 0.92, snapStrength: 0.08, handSensitivity: 8.0
};

const STATE = {
    mode: 'HAND', 
    phase: 'SCROLL', // SCROLL -> SINGLE_VIEW -> ASH_WAIT -> FINAL_ANIM -> FINAL_VIEW -> RESET
    
    scrollPos: 0, velocity: 0, isDragging: false, lastInputX: 0, selectedIndex: 0,
    
    remainingDeck: [],       // ç‰Œåº“æ•°æ®
    deckVisuals: [],         // åº•éƒ¨æ»šåŠ¨Mesh
    
    myHand: [],              // å·²æŠ½å–çš„ç‰Œæ•°æ® {data, isReversed, texture}
    currentDrawIndex: 0      // å½“å‰æ˜¯ç¬¬å‡ å¼  (0,1,2)
};

// ==========================================
// 1. 3D åŸºç¡€
// ==========================================
function createRoundedCardGeometry(width, height, radius) {
    const shape = new THREE.Shape();
    const x = -width/2, y = -height/2;
    shape.moveTo(x+radius, y); shape.lineTo(x+width-radius, y);
    shape.quadraticCurveTo(x+width, y, x+width, y+radius);
    shape.lineTo(x+width, y+height-radius);
    shape.quadraticCurveTo(x+width, y+height, x+width-radius, y+height);
    shape.lineTo(x+radius, y+height);
    shape.quadraticCurveTo(x, y+height, x, y+height-radius);
    shape.lineTo(x, y+radius); shape.quadraticCurveTo(x, y, x+radius, y);
    const geo = new THREE.ExtrudeGeometry(shape, { depth: 0.02, bevelEnabled: false, curveSegments: 12 });
    
    // UV Fix
    geo.computeBoundingBox();
    const range = new THREE.Vector2(geo.boundingBox.max.x-geo.boundingBox.min.x, geo.boundingBox.max.y-geo.boundingBox.min.y);
    const uv = geo.attributes.uv; const pos = geo.attributes.position;
    for(let i=0; i<pos.count; i++) uv.setXY(i, (pos.getX(i)-geo.boundingBox.min.x)/range.x, (pos.getY(i)-geo.boundingBox.min.y)/range.y);
    geo.center();
    return geo;
}

function createCardBackTexture() {
    const cvs = document.createElement('canvas'); cvs.width=512; cvs.height=800;
    const ctx = cvs.getContext('2d');
    ctx.fillStyle='#0a0a0a'; ctx.fillRect(0,0,512,800); // æ·±è‰²åº•
    ctx.strokeStyle='#333'; ctx.lineWidth=10; ctx.strokeRect(10,10,492,780);
    ctx.beginPath(); ctx.arc(256,400,50,0,Math.PI*2); ctx.fillStyle='#222'; ctx.fill();
    return new THREE.CanvasTexture(cvs);
}

// ==========================================
// 2. Three.js åˆå§‹åŒ–
// ==========================================
let scene, camera, renderer;
let deckGroup = new THREE.Group();
let displayGroup = new THREE.Group(); // ç”¨äºå•å¼ å±•ç¤ºå’Œæœ€ç»ˆå±•ç¤º
let ashSystems = [];
let sharedGeo = createRoundedCardGeometry(CONFIG.cardWidth, CONFIG.cardHeight, CONFIG.cardRadius);

function initThree() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene(); scene.background = new THREE.Color(0x000000);
    
    camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 15);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    const amb = new THREE.AmbientLight(0xffffff, 0.4); scene.add(amb);
    const point = new THREE.PointLight(0xffaa00, 1, 20); point.position.set(0, 2, 5); scene.add(point);

    scene.add(deckGroup);
    scene.add(displayGroup);

    resetGame();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    animate();
}

function resetGame() {
    // æ•°æ®é‡ç½®
    STATE.currentDrawIndex = 0;
    STATE.myHand = [];
    STATE.remainingDeck = [...FULL_DECK_DATA];
    STATE.phase = 'SCROLL';

    // è§†è§‰æ¸…ç†
    while(displayGroup.children.length > 0) displayGroup.remove(displayGroup.children[0]);
    document.getElementById('final-panel').classList.remove('active');
    
    // æ´—ç‰Œ
    for (let i = STATE.remainingDeck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [STATE.remainingDeck[i], STATE.remainingDeck[j]] = [STATE.remainingDeck[j], STATE.remainingDeck[i]];
    }

    createDeckVisuals();
    updateUIForPhase();
}

function createDeckVisuals() {
    while(deckGroup.children.length > 0) deckGroup.remove(deckGroup.children[0]);
    STATE.deckVisuals = [];
    const backTex = createCardBackTexture();

    STATE.remainingDeck.forEach((data, i) => {
        const mat = new THREE.MeshStandardMaterial({ map: backTex, roughness:0.5 });
        const mesh = new THREE.Mesh(sharedGeo, [mat, new THREE.MeshStandardMaterial({color:0x333})]);
        
        const group = new THREE.Group();
        group.add(mesh);
        group.position.set(i * CONFIG.cardSpacing, -3, 0); // åº•éƒ¨
        
        const cardObj = {
            group: group, mesh: mesh, data: data,
            isReversed: Math.random() < 0.5,
            textures: { back: backTex, front: null },
            flipped: false
        };
        new THREE.TextureLoader().load(data.url, (t) => cardObj.textures.front = t);

        deckGroup.add(group);
        STATE.deckVisuals.push(cardObj);
    });

    STATE.scrollPos = -((STATE.remainingDeck.length-1)*CONFIG.cardSpacing)/2;
}

// ==========================================
// 3. æ ¸å¿ƒå¾ªç¯ä¸åŠ¨ç”»
// ==========================================
function animate() {
    requestAnimationFrame(animate);
    
    updateScrollPhysics();
    updateDeckVisuals();
    updateAsh();
    
    // å¦‚æœæœ‰æœ€ç»ˆå±•ç¤ºçš„ç‰Œï¼ŒåŠ ä¸€ç‚¹æ‚¬æµ®åŠ¨ç”»
    displayGroup.children.forEach((child, i) => {
        if(STATE.phase === 'FINAL_VIEW') {
            child.position.y += Math.sin(Date.now()*0.001 + i)*0.002;
        }
    });

    renderer.render(scene, camera);
}

function updateScrollPhysics() {
    if (STATE.phase !== 'SCROLL') return;

    if (STATE.isDragging) STATE.velocity = (STATE.lastInputX - STATE.dragStartX) * CONFIG.scrollSpeed;
    STATE.scrollPos += STATE.velocity;

    if (!STATE.isDragging) {
        STATE.velocity *= CONFIG.friction;
        const count = STATE.deckVisuals.length;
        if (count === 0) return;
        const min = -((count-1)*CONFIG.cardSpacing);
        if (STATE.scrollPos > 0) STATE.velocity += (0 - STATE.scrollPos)*0.1;
        else if (STATE.scrollPos < min) STATE.velocity += (min - STATE.scrollPos)*0.1;
        else if (Math.abs(STATE.velocity) < 0.05) {
            const idx = Math.round(-STATE.scrollPos / CONFIG.cardSpacing);
            const target = -idx * CONFIG.cardSpacing;
            STATE.scrollPos += (target - STATE.scrollPos)*CONFIG.snapStrength;
            STATE.velocity *= 0.5;
            STATE.selectedIndex = Math.max(0, Math.min(count-1, idx));
        }
    }
}

function updateDeckVisuals() {
    // åªæœ‰åœ¨ SCROLL é˜¶æ®µæ‰æ˜¾ç¤ºåº•éƒ¨ç‰Œåº“
    deckGroup.visible = (STATE.phase === 'SCROLL');
    
    if (STATE.phase === 'SCROLL') {
        STATE.deckVisuals.forEach((c, i) => {
            const x = i * CONFIG.cardSpacing + STATE.scrollPos;
            c.group.position.x = x;
            const dist = Math.abs(x);
            const scale = 1 + 0.15 * Math.exp(-(dist*dist)/2);
            c.group.scale.set(scale, scale, scale);
            c.group.position.z = 1 - dist * 0.5; // ç¨å¾®é å‰
            
            // é€‰ä¸­çš„é«˜äº®ï¼ˆå‘å…‰ï¼‰
            if(dist < 0.5) c.mesh.material[0].emissive.setHex(0x222222);
            else c.mesh.material[0].emissive.setHex(0x000000);
        });
    }
}

// é€‰ä¸­ç¡®è®¤ -> å•å¼ å±•ç¤º
function confirmSelection() {
    if (STATE.phase !== 'SCROLL' || Math.abs(STATE.velocity) > 0.1) return;
    
    const card = STATE.deckVisuals[STATE.selectedIndex];
    if (!card) return;

    STATE.phase = 'SINGLE_VIEW';
    
    // 1. è®°å½•æ•°æ®
    STATE.myHand.push({
        data: card.data,
        isReversed: card.isReversed,
        texture: card.textures.front,
        backTexture: card.textures.back // Keep ref
    });

    // 2. å°†ç‰Œä»åº•éƒ¨ç§»é™¤é€»è¾‘
    STATE.deckVisuals.splice(STATE.selectedIndex, 1);
    STATE.remainingDeck.splice(STATE.selectedIndex, 1);
    
    // 3. å…‹éš†ä¸€ä¸ªç”¨äºå±•ç¤ºçš„ç‰Œï¼ˆå› ä¸ºåŸç‰Œåº“è¿˜è¦é‡æ’ï¼‰
    // æˆ–è€…ç›´æ¥æŠŠè¿™å¼ ç‰Œæ‹¿å‡ºæ¥
    deckGroup.remove(card.group);
    displayGroup.add(card.group);
    
    // 4. åŠ¨ç”»ï¼šé£åˆ°å±å¹•ä¸­å¿ƒï¼Œç¿»è½¬
    const isRev = card.isReversed;
    let progress = 0;
    const startPos = card.group.position.clone();
    
    function animateReveal() {
        progress += 0.025;
        const ease = 1 - Math.pow(1 - progress, 3);
        
        // Pos: (0, 0, 8) æ€¼è„¸
        card.group.position.lerpVectors(startPos, new THREE.Vector3(0, 0, 9), ease);
        card.group.rotation.y += 0.15; // æ—‹è½¬

        // ç¿»é¢é€»è¾‘
        if (!card.flipped && card.group.rotation.y > Math.PI/2) {
             if (card.textures.front) {
                card.mesh.material[0].map = card.textures.front;
                card.mesh.material[0].needsUpdate = true;
             }
             card.flipped = true;
             // å¦‚æœé€†ä½ï¼Œç¿»è¿‡æ¥åZè½´è¦æ˜¯å€’çš„
             if (isRev) card.group.rotation.z = Math.PI;
        }

        if (progress < 1 || card.group.rotation.y < Math.PI * 2) {
            requestAnimationFrame(animateReveal);
        } else {
            // ä¿®æ­£è§’åº¦
            card.group.rotation.y = 0;
            if (isRev) card.group.rotation.z = Math.PI;
            
            // æ˜¾ç¤ºå•å¼ ä¿¡æ¯
            showSingleCardInfo(card);
            STATE.phase = 'ASH_WAIT';
        }
    }
    animateReveal();
}

function showSingleCardInfo(card) {
    const el = document.getElementById('single-card-info');
    const nameEl = document.getElementById('single-name');
    const descEl = document.getElementById('single-desc');
    
    const status = card.isReversed ? "ã€é€†ä½ã€‘" : "ã€æ­£ä½ã€‘";
    const meaning = card.isReversed ? card.data.rev : card.data.up;
    
    nameEl.innerText = `${card.data.name} ${status}`;
    descEl.innerText = meaning;
    nameEl.style.color = card.isReversed ? "#ff6b6b" : "#4caf50";
    
    el.style.opacity = 1;
    // éšè—å¼•å¯¼æ–‡æ¡ˆ
    document.getElementById('guide-text').style.opacity = 0;
    document.getElementById('sub-guide').style.opacity = 0;
}

// ç¡®è®¤è®°å¿† -> åŒ–ä¸ºå…‰ç‚¹æ¶ˆæ•£
function dismissCard() {
    if (STATE.phase !== 'ASH_WAIT') return;
    
    // è·å–å½“å‰å±•ç¤ºçš„é‚£å¼ ç‰Œ
    const cardGroup = displayGroup.children[0]; // åº”è¯¥åªæœ‰ä¸€å¼ 
    createAsh(cardGroup);
    displayGroup.remove(cardGroup);
    
    document.getElementById('single-card-info').style.opacity = 0;
    
    // æ£€æŸ¥è¿›åº¦
    STATE.currentDrawIndex++;
    
    if (STATE.currentDrawIndex < 3) {
        // ç»§ç»­æŠ½ä¸‹ä¸€å¼ 
        setTimeout(() => {
            STATE.phase = 'SCROLL';
            // é‡ç½®åº•éƒ¨ç‰Œåº“ä½ç½®
            STATE.scrollPos = -((STATE.deckVisuals.length-1)*CONFIG.cardSpacing)/2;
            STATE.velocity = 0;
            updateUIForPhase();
        }, 1500); // ç­‰ç²’å­é£˜ä¸€ä¼š
    } else {
        // ä¸‰å¼ æŠ½å®Œï¼Œè¿›å…¥æœ€ç»ˆå¬å”¤
        setTimeout(() => {
            enterGrandSummoning();
        }, 2000);
    }
}

// ==========================================
// 4. ç»ˆç„‰å¬å”¤ (The Grand Summoning)
// ==========================================
function enterGrandSummoning() {
    STATE.phase = 'FINAL_ANIM';
    document.getElementById('guide-text').innerText = "";
    
    // é‡å»ºä¸‰å¼ ç‰Œ
    STATE.myHand.forEach((handData, i) => {
        const mat = new THREE.MeshStandardMaterial({ 
            map: handData.texture, // ç›´æ¥ç”¨å­˜å¥½çš„æ­£é¢å›¾
            roughness: 0.4, 
            emissive: 0x222222 // å¾®å…‰
        });
        const mesh = new THREE.Mesh(sharedGeo, [mat, new THREE.MeshStandardMaterial({color:0xffffff})]);
        const group = new THREE.Group();
        group.add(mesh);
        
        // åˆå§‹ä½ç½®ï¼šæ·±å¤„ï¼Œä¸å¯è§
        group.position.set((i-1)*3.5, 0, -20); 
        group.scale.set(0,0,0);
        if(handData.isReversed) group.rotation.z = Math.PI;
        
        displayGroup.add(group);
        
        // å»¶è¿Ÿé£å…¥åŠ¨ç”»
        setTimeout(() => {
            animateSummon(group, (i-1)*3.2); // ç›®æ ‡X: å·¦(-3.2), ä¸­(0), å³(3.2)
        }, i * 600);
    });

    // æ‰€æœ‰äººå°±ä½å
    setTimeout(() => {
        STATE.phase = 'FINAL_VIEW';
        generateSummary();
    }, 2500);
}

function animateSummon(obj, targetX) {
    let progress = 0;
    function loop() {
        progress += 0.02;
        const ease = 1 - Math.pow(1 - progress, 3);
        
        obj.position.z = -20 + (20 + 2) * ease; // ä»-20 åˆ° 2
        obj.position.x = targetX; // ä¿æŒX
        obj.scale.set(ease, ease, ease);
        
        // æ—‹è½¬ç‰¹æ•ˆ
        obj.rotation.y = (1-ease) * Math.PI * 2; // è½¬ä¸€åœˆåœä¸‹

        if(progress < 1) requestAnimationFrame(loop);
    }
    loop();
}

function generateSummary() {
    const panel = document.getElementById('final-panel');
    const content = document.getElementById('final-summary-text');
    
    const c1 = STATE.myHand[0];
    const c2 = STATE.myHand[1];
    const c3 = STATE.myHand[2];
    
    const txt1 = c1.isReversed ? c1.data.rev : c1.data.up;
    const txt2 = c2.isReversed ? c2.data.rev : c2.data.up;
    const txt3 = c3.isReversed ? c3.data.rev : c3.data.up;
    
    content.innerHTML = `
        <p><strong>è¿‡å»ä¹‹å› ï¼š</strong>${c1.data.name} (${c1.isReversed?'é€†':'æ­£'})<br>
        <span style="color:#aaa">${txt1}ã€‚è¿™å¥ å®šäº†å½“å‰å±€é¢çš„åŸºç¡€èƒ½é‡ã€‚</span></p>
        
        <p><strong>ç°åœ¨ä¹‹æœï¼š</strong>${c2.data.name} (${c2.isReversed?'é€†':'æ­£'})<br>
        <span style="color:#aaa">${txt2}ã€‚è¿™æ˜¯ä½ æ­¤åˆ»æ­£åœ¨ç»å†çš„æ ¸å¿ƒè¯¾é¢˜ã€‚</span></p>
        
        <p><strong>æœªæ¥ä¹‹ç›¸ï¼š</strong>${c3.data.name} (${c3.isReversed?'é€†':'æ­£'})<br>
        <span style="color:#aaa">${txt3}ã€‚è‹¥ä¿æŒå½“å‰å¿ƒå¢ƒï¼Œè¿™æ˜¯æœ€å¯èƒ½æ˜¾åŒ–çš„æ–¹å‘ã€‚</span></p>
        
        <p style="margin-top:20px; color:#ffd700; font-style:italic;">
        â€œå‘½è¿ä¹‹æ²³ä»${c1.data.name.split(' ')[1]}æµå‘${c3.data.name.split(' ')[1]}ï¼Œ
        å”¯æœ‰è§‰å¯Ÿå½“ä¸‹çš„${c2.data.name.split(' ')[1]}ï¼Œæ–¹èƒ½æŒæ¡èˆªå‘ã€‚â€
        </p>
    `;
    
    panel.classList.add('active');
}

// æœ€ç»ˆå…¨éƒ¨ç‡ƒçƒ§
function burnAllAndReset() {
    if (STATE.phase !== 'FINAL_VIEW') return;
    STATE.phase = 'RESET';
    
    displayGroup.children.forEach(c => createAsh(c));
    while(displayGroup.children.length > 0) displayGroup.remove(displayGroup.children[0]);
    
    document.getElementById('final-panel').classList.remove('active');
    
    setTimeout(() => {
        resetGame();
    }, 2000);
}

// ==========================================
// 5. ç²’å­ç³»ç»Ÿ (Ash)
// ==========================================
function createAsh(obj) {
    const geo = new THREE.BufferGeometry();
    const count = 3000;
    const pos = [], spd = [];
    const worldPos = new THREE.Vector3();
    obj.getWorldPosition(worldPos);

    for(let i=0; i<count; i++) {
        pos.push(
            worldPos.x + (Math.random()-0.5)*2,
            worldPos.y + (Math.random()-0.5)*3.5, 
            worldPos.z
        );
        spd.push(Math.random()*0.05 + 0.02);
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    geo.setAttribute('speed', new THREE.Float32BufferAttribute(spd, 1));
    const mat = new THREE.PointsMaterial({color:0xffffff, size:0.04, transparent:true, opacity:1, blending:THREE.AdditiveBlending});
    const sys = new THREE.Points(geo, mat);
    scene.add(sys);
    ashSystems.push(sys);
}

function updateAsh() {
    for (let i = ashSystems.length - 1; i >= 0; i--) {
        const sys = ashSystems[i];
        const pos = sys.geometry.attributes.position.array;
        const spd = sys.geometry.attributes.speed.array;
        sys.material.opacity -= 0.02; // æ¶ˆå¤±å¿«ä¸€ç‚¹
        for(let j=0; j<pos.length/3; j++) {
            pos[j*3+1] += spd[j];
            pos[j*3] += (Math.random()-0.5)*0.05;
        }
        sys.geometry.attributes.position.needsUpdate = true;
        if (sys.material.opacity <= 0) {
            scene.remove(sys);
            ashSystems.splice(i, 1);
        }
    }
}

// ==========================================
// 6. UI & Input
// ==========================================
function updateUIForPhase() {
    const titles = PHASE_TITLES;
    const descs = PHASE_DESC;
    const idx = STATE.currentDrawIndex;
    
    const guide = document.getElementById('guide-text');
    const sub = document.getElementById('sub-guide');
    
    guide.style.opacity = 1;
    sub.style.opacity = 1;
    guide.innerText = titles[idx];
    sub.innerText = descs[idx] + " â€¢ æ»‘åŠ¨é€‰æ‹©";
}

// Input Handlers
window.addEventListener('mousedown', e => {
    if (STATE.mode!=='MOUSE') return;
    if (STATE.phase === 'SCROLL') {
        STATE.isDragging = true; STATE.dragStartX = (e.clientX/window.innerWidth)*2-1; STATE.lastInputX = STATE.dragStartX; STATE.velocity = 0;
    } else if (STATE.phase === 'ASH_WAIT') {
        dismissCard();
    } else if (STATE.phase === 'FINAL_VIEW') {
        burnAllAndReset();
    }
});
window.addEventListener('mousemove', e => {
    if (STATE.mode!=='MOUSE') return;
    const x = (e.clientX/window.innerWidth)*2-1;
    if (STATE.isDragging) { STATE.velocity = (x - STATE.lastInputX) * CONFIG.scrollSpeed; STATE.lastInputX = x; }
});
window.addEventListener('mouseup', () => {
    if (STATE.isDragging) { STATE.isDragging = false; if(Math.abs(STATE.velocity)<0.01) confirmSelection(); }
});

function onResults(res) {
    if (STATE.mode !== 'HAND' || !res.multiHandLandmarks[0]) return;
    const lm = res.multiHandLandmarks[0];
    const x = (1 - lm[8].x)*2-1;
    const isPinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05;
    const isFist = Math.hypot(lm[8].x-lm[0].x, lm[8].y-lm[0].y) < 0.25;
    
    updateGestureUI(isFist?'FIST':(isPinch?'PINCH':'OPEN'));

    if (STATE.phase === 'SCROLL') {
        if (isPinch) {
            if (!STATE.isDragging) { STATE.isDragging = true; STATE.dragStartX = x; STATE.lastInputX = x; } 
            else { STATE.velocity = (x - STATE.lastInputX) * CONFIG.handSensitivity; STATE.lastInputX = x; }
        } else {
            if (STATE.isDragging) STATE.isDragging = false;
            if (isFist && Math.abs(STATE.velocity) < 0.1) confirmSelection();
        }
    } else if (STATE.phase === 'ASH_WAIT') {
        if (isFist) dismissCard();
    } else if (STATE.phase === 'FINAL_VIEW') {
        if (isFist) burnAllAndReset();
    }
}

function updateGestureUI(txt) {
    const el = document.getElementById('gesture-indicator');
    el.innerText = txt; el.style.color = txt==='OPEN' ? '#aaa' : '#ffeb3b';
}
document.getElementById('btn-mode-hand').onclick = () => { STATE.mode='HAND'; document.getElementById('video-preview').style.display='block'; setupCamera(); };
document.getElementById('btn-mode-mouse').onclick = () => { STATE.mode='MOUSE'; document.getElementById('video-preview').style.display='none'; };

async function setupCamera() {
    const vid = document.getElementById('video-preview');
    const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.7});
    hands.onResults(onResults);
    const cam = new Camera(vid, {onFrame: async()=>{await hands.send({image:vid})}, width:640, height:480});
    await cam.start();
    document.getElementById('loader').style.display='none';
}

setTimeout(()=>document.getElementById('loader').style.display='none', 1000);
initThree();
</script>
</body>
</html>