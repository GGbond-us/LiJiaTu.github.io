<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js å¡”ç½— - æ—¶é—´æµä¸‰ç‰Œé˜µ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Microsoft YaHei', sans-serif; color: #fff; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        /* é¡¶éƒ¨æ§åˆ¶ */
        .hud-panel { position: absolute; pointer-events: auto; }
        #controls { top: 20px; left: 20px; display: flex; gap: 10px; align-items: center; }
        button { 
            background: rgba(0,0,0,0.6); color: #fff; border: 1px solid #666; 
            padding: 6px 15px; cursor: pointer; transition: all 0.3s; border-radius: 4px;
        }
        button:hover { background: #fff; color: #000; }
        
        #video-preview { width: 120px; height: 90px; transform: scaleX(-1); border: 1px solid #333; display: none; margin-top: 10px; opacity: 0.8; }
        
        /* å†å²è®°å½• */
        #history-panel {
            position: absolute; top: 20px; right: 20px; width: 260px; max-height: 400px;
            background: rgba(0, 0, 0, 0.85); border: 1px solid #333; border-radius: 8px; padding: 15px;
            pointer-events: auto; display: flex; flex-direction: column; overflow-y: auto;
        }
        .history-item { font-size: 12px; color: #ccc; margin-bottom: 5px; border-bottom: 1px solid #222; padding-bottom: 4px; }
        
        /* çŠ¶æ€æŒ‡å¼• */
        #guide-text { 
            position: absolute; top: 15%; width: 100%; text-align: center; 
            font-size: 24px; text-shadow: 0 0 10px rgba(255,255,255,0.5); letter-spacing: 2px;
            transition: all 0.5s;
        }
        #status-text { 
            position: absolute; bottom: 120px; width: 100%; text-align: center; 
            font-size: 14px; opacity: 0.6; pointer-events: none; 
        }
        
        /* æœ€ç»ˆè§£è¯»é¢æ¿ */
        #reading-panel { 
            position: absolute; bottom: 0; left: 0; width: 100%; height: 45%; 
            background: linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,0.8));
            transform: translateY(100%); transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
            pointer-events: auto; display: flex; flex-direction: column; align-items: center; padding-top: 20px;
        }
        #reading-panel.active { transform: translateY(0); }
        
        .reading-content { display: flex; justify-content: center; gap: 20px; width: 90%; max-width: 1200px; }
        .reading-card { flex: 1; background: rgba(20,20,20,0.8); border: 1px solid #444; padding: 15px; border-radius: 8px; font-size: 13px; line-height: 1.5; }
        .reading-card h3 { color: #d4af37; margin: 0 0 10px 0; font-size: 16px; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .reading-card h4 { color: #fff; margin: 0 0 5px 0; font-size: 14px; }
        .reading-card .pos-desc { color: #888; font-style: italic; margin-bottom: 8px; font-size: 12px; }
        
        #final-action { margin-top: 20px; color: #aaa; font-size: 14px; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.2rem; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">åˆå§‹åŒ–ä¸­...</div>

    <div id="ui-layer">
        <div id="controls" class="hud-panel">
            <button id="btn-mode-hand">ğŸ– æ‰‹åŠ¿æ¨¡å¼</button>
            <button id="btn-mode-mouse">ğŸ–±ï¸ é¼ æ ‡æ¨¡å¼</button>
            <div id="gesture-indicator" style="font-size:12px; color:#aaa; margin-top:5px;">ç­‰å¾…ä¸­...</div>
            <video id="video-preview" playsinline></video>
        </div>

        <div id="history-panel">
            <div style="border-bottom:1px solid #444; padding-bottom:5px; margin-bottom:5px;">
                æŠ½å–å†å² <span id="deck-count" style="float:right; color:#888;"></span>
            </div>
            <div id="history-list"></div>
        </div>

        <div id="guide-text">è¯·æŠ½å–ç¬¬ä¸€å¼ ï¼šè¿‡å» / æˆå› </div>
        <div id="status-text">æ»‘åŠ¨ä¸‹æ–¹ç‰Œåº“é€‰æ‹© â€¢ å±…ä¸­ç¡®è®¤</div>

        <!-- åº•éƒ¨è§£è¯»é¢æ¿ -->
        <div id="reading-panel">
            <div class="reading-content">
                <div class="reading-card" id="read-pos-1"></div>
                <div class="reading-card" id="read-pos-2"></div>
                <div class="reading-card" id="read-pos-3"></div>
            </div>
            <div id="final-action">æ¡æ‹³ æˆ– ç‚¹å‡»ä»»æ„å¤„ -> ç‡ƒå°½ä¸€åˆ‡ï¼Œé‡æ–°å¼€å§‹</div>
        </div>
    </div>

    <div id="canvas-container"></div>

<script>
// ==========================================
// 0. æ•°æ®å®šä¹‰
// ==========================================
// å®Œæ•´22å¼ å¤§é˜¿å¡é‚£
const FULL_DECK_DATA = [
    { id: 0, name: "0. æ„šè€…", url: "https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg", up: "æ–°çš„å¼€å§‹ã€å¤©çœŸã€è‡ªç”±ç²¾ç¥", rev: "é²è½ã€è½»ç‡ã€é£é™©" },
    { id: 1, name: "I. é­”æœ¯å¸ˆ", url: "https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg", up: "åˆ›é€ åŠ›ã€æŠ€èƒ½ã€æ„å¿—åŠ›", rev: "æ¬ºéª—ã€æ‰åè¢«åŸ‹æ²¡" },
    { id: 2, name: "II. å¥³ç¥­å¸", url: "https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg", up: "ç›´è§‰ã€æ½œæ„è¯†ã€ç¥ç§˜", rev: "ç§˜å¯†æ³„éœ²ã€å‹æŠ‘æƒ…æ„Ÿ" },
    { id: 3, name: "III. çš‡å", url: "https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg", up: "ä¸°é¥¶ã€æ¯æ€§ã€è‡ªç„¶", rev: "ä¾èµ–ã€åˆ›é€ åŠ›å—é˜»" },
    { id: 4, name: "IV. çš‡å¸", url: "https://upload.wikimedia.org/wikipedia/commons/c/c3/RWS_Tarot_04_Emperor.jpg", up: "æƒå¨ã€ç»“æ„ã€ç¨³å›º", rev: "æš´æ”¿ã€åƒµåŒ–ã€å†·é…·" },
    { id: 5, name: "V. æ•™çš‡", url: "https://upload.wikimedia.org/wikipedia/commons/8/8d/RWS_Tarot_05_Hierophant.jpg", up: "ä¼ ç»Ÿã€ä¿¡ä»°ã€ç²¾ç¥æŒ‡å¼•", rev: "æŒ‘æˆ˜ä¼ ç»Ÿã€è™šä¼ªã€è¯¯å¯¼" },
    { id: 6, name: "VI. æ‹äºº", url: "https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_06_Lovers.jpg", up: "çˆ±ã€å’Œè°ã€é€‰æ‹©", rev: "åˆ†ç¦»ã€ä¸å¹³è¡¡ã€å†²çª" },
    { id: 7, name: "VII. æˆ˜è½¦", url: "https://upload.wikimedia.org/wikipedia/commons/9/9b/RWS_Tarot_07_Chariot.jpg", up: "æ§åˆ¶ã€æ„å¿—åŠ›ã€èƒœåˆ©", rev: "å¤±æ§ã€æ”»å‡»æ€§ã€å¤±è´¥" },
    { id: 8, name: "VIII. åŠ›é‡", url: "https://upload.wikimedia.org/wikipedia/commons/f/f5/RWS_Tarot_08_Strength.jpg", up: "åŠ›é‡ã€å‹‡æ°”ã€è€å¿ƒ", rev: "è½¯å¼±ã€è‡ªæˆ‘æ€€ç–‘ã€ç”Ÿç—…" },
    { id: 9, name: "IX. éšå£«", url: "https://upload.wikimedia.org/wikipedia/commons/4/4d/RWS_Tarot_09_Hermit.jpg", up: "å†…çœã€å­¤ç‹¬ã€æŒ‡å¼•", rev: "å­¤ç«‹ã€è¿·å¤±ã€æ‹’ç»å»ºè®®" },
    { id: 10, name: "X. å‘½è¿ä¹‹è½®", url: "https://upload.wikimedia.org/wikipedia/commons/3/3c/RWS_Tarot_10_Wheel_of_Fortune.jpg", up: "å¥½è¿ã€å› æœã€è½¬æŠ˜ç‚¹", rev: "å„è¿ã€æŠµæŠ—æ”¹å˜" },
    { id: 11, name: "XI. æ­£ä¹‰", url: "https://upload.wikimedia.org/wikipedia/commons/e/e0/RWS_Tarot_11_Justice.jpg", up: "æ­£ä¹‰ã€å…¬å¹³ã€çœŸç†", rev: "ä¸å…¬ã€ä¸è¯šå®ã€é€ƒé¿è´£ä»»" },
    { id: 12, name: "XII. å€’åŠäºº", url: "https://upload.wikimedia.org/wikipedia/commons/2/2b/RWS_Tarot_12_Hanged_Man.jpg", up: "ç‰ºç‰²ã€ç­‰å¾…ã€æ–°è§†è§’", rev: "æ‹–å»¶ã€æ— è°“çš„ç‰ºç‰²" },
    { id: 13, name: "XIII. æ­»ç¥", url: "https://upload.wikimedia.org/wikipedia/commons/d/d7/RWS_Tarot_13_Death.jpg", up: "ç»“æŸã€è½¬å˜ã€é‡ç”Ÿ", rev: "æŠ—æ‹’æ”¹å˜ã€åœæ»" },
    { id: 14, name: "XIV. èŠ‚åˆ¶", url: "https://upload.wikimedia.org/wikipedia/commons/f/f8/RWS_Tarot_14_Temperance.jpg", up: "å¹³è¡¡ã€é€‚åº¦ã€è€å¿ƒ", rev: "å¤±è¡¡ã€è¿‡åº¦ã€åŒ†å¿™" },
    { id: 15, name: "XV. æ¶é­”", url: "https://upload.wikimedia.org/wikipedia/commons/5/55/RWS_Tarot_15_Devil.jpg", up: "æŸç¼šã€ç‰©è´¨ä¸»ä¹‰ã€è¯±æƒ‘", rev: "æ‰“ç ´æŸç¼šã€é‡è·è‡ªç”±" },
    { id: 16, name: "XVI. é«˜å¡”", url: "https://upload.wikimedia.org/wikipedia/commons/5/53/RWS_Tarot_16_Tower.jpg", up: "çªç„¶çš„å‰§å˜ã€ç¾éš¾ã€è§‰é†’", rev: "é¿å…ç¾éš¾ã€ææƒ§æ”¹å˜" },
    { id: 17, name: "XVII. æ˜Ÿæ˜Ÿ", url: "https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_17_Star.jpg", up: "å¸Œæœ›ã€ä¿¡å¿µã€çµæ„Ÿ", rev: "ç»æœ›ã€ç¼ºä¹ä¿¡å¿ƒ" },
    { id: 18, name: "XVIII. æœˆäº®", url: "https://upload.wikimedia.org/wikipedia/commons/7/7f/RWS_Tarot_18_Moon.jpg", up: "å¹»è§‰ã€ææƒ§ã€æ½œæ„è¯†", rev: "é‡Šæ”¾ææƒ§ã€ä¸å¹¸" },
    { id: 19, name: "XIX. å¤ªé˜³", url: "https://upload.wikimedia.org/wikipedia/commons/1/17/RWS_Tarot_19_Sun.jpg", up: "å¿«ä¹ã€æˆåŠŸã€æ´»åŠ›", rev: "æ¶ˆæ²‰ã€æš‚æ—¶çš„æŒ«æŠ˜" },
    { id: 20, name: "XX. å®¡åˆ¤", url: "https://upload.wikimedia.org/wikipedia/commons/d/dd/RWS_Tarot_20_Judgement.jpg", up: "å®¡åˆ¤ã€é‡ç”Ÿã€å†…å¿ƒå¬å”¤", rev: "è‡ªæˆ‘æ€€ç–‘ã€æ‹’ç»å¬å”¤" },
    { id: 21, name: "XXI. ä¸–ç•Œ", url: "https://upload.wikimedia.org/wikipedia/commons/f/ff/RWS_Tarot_21_World.jpg", up: "å®Œæˆã€æ•´åˆã€æˆå°±", rev: "æœªå®Œæˆã€ç¼ºä¹é—­ç¯" }
];

// é˜µæ³•ä½ç½®å«ä¹‰å®šä¹‰
const SPREAD_DEFINITIONS = [
    { title: "ä½ç½®1ï¼šè¿‡å» / æˆå› ",  up_desc: "å®Œæ•´è¡¨è¾¾/å¥ åŸºçš„èƒ½é‡", rev_desc: "é˜»å¡/æœªå®Œæˆ/å‹æŠ‘çš„èƒ½é‡" },
    { title: "ä½ç½®2ï¼šç°åœ¨ / ç°çŠ¶",  up_desc: "æ˜æ˜¾çš„è¯¾é¢˜/éœ€è¦æ•´åˆçš„èƒ½é‡", rev_desc: "éšç§˜çš„è¯¾é¢˜/æŠ—æ‹’çš„èƒ½é‡" },
    { title: "ä½ç½®3ï¼šæœªæ¥ / å‘å±•",  up_desc: "é¡ºç•…æ˜¾åŒ–/ç›´æ¥ç»“æœ", rev_desc: "å»¶è¿Ÿæ˜¾åŒ–/éœ€è¦è°ƒæ•´/å†…éƒ¨é˜»åŠ›" }
];

const CONFIG = {
    cardWidth: 2.0, cardHeight: 3.5, cardRadius: 0.1, cardSpacing: 2.5,
    scrollSpeed: 4.0, friction: 0.92, snapStrength: 0.08, handSensitivity: 8.0,
    slotPositions: [ // ä¸Šæ–¹ä¸‰ä¸ªå¡æ§½åæ ‡
        new THREE.Vector3(-3.5, 1.8, 0), // è¿‡å»
        new THREE.Vector3(0, 1.8, 0),    // ç°åœ¨
        new THREE.Vector3(3.5, 1.8, 0)   // æœªæ¥
    ]
};

const STATE = {
    mode: 'HAND', 
    phase: 'SCROLL', // SCROLL -> ANIMATING -> READING -> ASH
    
    // æ»šåŠ¨æ¡çŠ¶æ€
    scrollPos: 0, velocity: 0, isDragging: false, lastInputX: 0, selectedIndex: 0,
    
    // ç‰Œåº“ä¸å¡æ§½
    remainingDeck: [],       // å‰©ä½™æœªæŠ½å–çš„ç‰Œæ•°æ®
    deckVisuals: [],         // åº•éƒ¨æ»šåŠ¨æ¡é‡Œçš„ Mesh å¯¹è±¡
    placedCards: [],         // å·²ç»æŠ½å‡ºçš„3å¼ ç‰Œ Mesh å¯¹è±¡
    
    currentSlot: 0           // å½“å‰æ­£åœ¨æŠ½ç¬¬å‡ å¼  (0, 1, 2)
};

// ==========================================
// 1. 3D åŸºç¡€æ„å»º
// ==========================================
function createRoundedCardGeometry(width, height, radius) {
    const shape = new THREE.Shape();
    const x = -width/2, y = -height/2;
    shape.moveTo(x+radius, y); shape.lineTo(x+width-radius, y);
    shape.quadraticCurveTo(x+width, y, x+width, y+radius);
    shape.lineTo(x+width, y+height-radius);
    shape.quadraticCurveTo(x+width, y+height, x+width-radius, y+height);
    shape.lineTo(x+radius, y+height);
    shape.quadraticCurveTo(x, y+height, x, y+height-radius);
    shape.lineTo(x, y+radius); shape.quadraticCurveTo(x, y, x+radius, y);

    const geo = new THREE.ExtrudeGeometry(shape, { depth: 0.02, bevelEnabled: false, curveSegments: 12 });
    geo.computeBoundingBox();
    const min = geo.boundingBox.min, max = geo.boundingBox.max;
    const range = new THREE.Vector2(max.x-min.x, max.y-min.y);
    const uv = geo.attributes.uv; const pos = geo.attributes.position;
    for(let i=0; i<pos.count; i++) uv.setXY(i, (pos.getX(i)-min.x)/range.x, (pos.getY(i)-min.y)/range.y);
    geo.center();
    return geo;
}

function createCardBackTexture() {
    const cvs = document.createElement('canvas'); cvs.width=512; cvs.height=800;
    const ctx = cvs.getContext('2d');
    ctx.fillStyle='#fff'; ctx.fillRect(0,0,512,800);
    ctx.strokeStyle='#f0f0f0'; ctx.lineWidth=10; ctx.strokeRect(10,10,492,780);
    return new THREE.CanvasTexture(cvs);
}

// ==========================================
// 2. Three.js åˆå§‹åŒ–
// ==========================================
let scene, camera, renderer;
let deckGroup = new THREE.Group(); // åº•éƒ¨æ»šåŠ¨ç»„
let slotsGroup = new THREE.Group(); // ä¸Šæ–¹å¡æ§½ç»„
let ashSystems = []; // ç²’å­ç³»ç»Ÿæ•°ç»„
let sharedGeo = createRoundedCardGeometry(CONFIG.cardWidth, CONFIG.cardHeight, CONFIG.cardRadius);

function initThree() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene(); scene.background = new THREE.Color(0x000000);
    
    camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 16); // ç¨å¾®æ‹‰è¿œ

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    const amb = new THREE.AmbientLight(0xffffff, 0.6); scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(0, 5, 10); scene.add(dir);

    // ä¸¤ä¸ªåˆ†ç»„
    deckGroup.position.y = -2.5; // åº•éƒ¨
    scene.add(deckGroup);
    scene.add(slotsGroup);

    resetDeck();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    animate();
}

function resetDeck() {
    // é‡ç½®çŠ¶æ€
    STATE.currentSlot = 0;
    STATE.placedCards = [];
    STATE.deckVisuals = [];
    STATE.phase = 'SCROLL';
    STATE.remainingDeck = [...FULL_DECK_DATA];
    
    // æ´—ç‰Œ
    for (let i = STATE.remainingDeck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [STATE.remainingDeck[i], STATE.remainingDeck[j]] = [STATE.remainingDeck[j], STATE.remainingDeck[i]];
    }

    createDeckVisuals();
    updateGuideText();
    document.getElementById('deck-count').innerText = `å‰©ä½™: 22`;
    document.getElementById('reading-panel').classList.remove('active');
}

function createDeckVisuals() {
    // æ¸…ç©ºåº•éƒ¨æ˜¾ç¤º
    while(deckGroup.children.length > 0) deckGroup.remove(deckGroup.children[0]);
    STATE.deckVisuals = [];
    
    const backTex = createCardBackTexture();

    STATE.remainingDeck.forEach((data, i) => {
        const mat = new THREE.MeshStandardMaterial({ map: backTex, roughness:0.6, metalness:0.1 });
        const side = new THREE.MeshStandardMaterial({ color:0xeeeeee });
        const mesh = new THREE.Mesh(sharedGeo, [mat, side]);
        
        const group = new THREE.Group();
        group.add(mesh);
        group.position.x = i * CONFIG.cardSpacing;
        
        const cardObj = {
            group: group, mesh: mesh, data: data,
            isReversed: Math.random() < 0.5,
            textures: { back: backTex, front: null },
            flipped: false
        };
        // æ‡’åŠ è½½
        new THREE.TextureLoader().load(data.url, (t) => cardObj.textures.front = t);

        deckGroup.add(group);
        STATE.deckVisuals.push(cardObj);
    });

    STATE.scrollPos = -((STATE.remainingDeck.length-1)*CONFIG.cardSpacing)/2;
}

// ==========================================
// 3. æ ¸å¿ƒé€»è¾‘ (ç‰©ç†+çŠ¶æ€æœº)
// ==========================================
function animate() {
    requestAnimationFrame(animate);
    
    updatePhysics();
    updateDeckVisuals(); // ç¼©æ”¾æ•ˆæœ
    updateAsh();
    
    renderer.render(scene, camera);
}

function updatePhysics() {
    if (STATE.phase !== 'SCROLL') return;

    // æ‹–æ‹½ç‰©ç†
    if (STATE.isDragging) {
        STATE.velocity = (STATE.lastInputX - STATE.dragStartX) * CONFIG.scrollSpeed;
    } 
    STATE.scrollPos += STATE.velocity;

    if (!STATE.isDragging) {
        STATE.velocity *= CONFIG.friction;
        const count = STATE.deckVisuals.length;
        if (count === 0) return;

        const min = -((count-1)*CONFIG.cardSpacing);
        if (STATE.scrollPos > 0) STATE.velocity += (0 - STATE.scrollPos)*0.1;
        else if (STATE.scrollPos < min) STATE.velocity += (min - STATE.scrollPos)*0.1;
        else if (Math.abs(STATE.velocity) < 0.05) {
            // å¸é™„
            const idx = Math.round(-STATE.scrollPos / CONFIG.cardSpacing);
            const target = -idx * CONFIG.cardSpacing;
            STATE.scrollPos += (target - STATE.scrollPos)*CONFIG.snapStrength;
            STATE.velocity *= 0.5;
            STATE.selectedIndex = Math.max(0, Math.min(count-1, idx));
        }
    }
}

function updateDeckVisuals() {
    STATE.deckVisuals.forEach((c, i) => {
        const x = i * CONFIG.cardSpacing + STATE.scrollPos;
        c.group.position.x = x;
        // ä¸­å¿ƒå‡¸èµ·æ•ˆæœ
        const dist = Math.abs(x);
        const scale = 1 + 0.15 * Math.exp(-(dist*dist)/2);
        c.group.scale.set(scale, scale, scale);
        c.group.position.z = 2 - dist * 0.5;
    });
}

function confirmSelection() {
    if (STATE.phase !== 'SCROLL' || Math.abs(STATE.velocity) > 0.1) return;
    if (STATE.currentSlot >= 3) return; // å·²ç»æŠ½äº†3å¼ 

    const card = STATE.deckVisuals[STATE.selectedIndex];
    if (!card) return;

    STATE.phase = 'ANIMATING'; // é”å®šè¾“å…¥

    // 1. ä»åº•éƒ¨æ•°ç»„ç§»é™¤
    STATE.deckVisuals.splice(STATE.selectedIndex, 1);
    STATE.remainingDeck.splice(STATE.selectedIndex, 1); // é€»è¾‘ç§»é™¤
    deckGroup.remove(card.group); // è§†è§‰ç§»é™¤
    
    // 2. åŠ å…¥åˆ°ä¸Šå±‚å¡æ§½ç»„
    slotsGroup.add(card.group);
    STATE.placedCards.push(card);

    // 3. ä¿®æ­£åæ ‡ (ä» deckGroup å±€éƒ¨åæ ‡è½¬æ¢åˆ° slotsGroup)
    // deckGroup åœ¨ y=-2.5. slotGroup åœ¨ y=0.
    // æ‰€ä»¥åŸæ¥çš„ y=0 å…¶å®æ˜¯ y=-2.5
    card.group.position.y = -2.5; 
    // x ä¿æŒä¸å˜ (å½“å‰å¸é™„ä½ç½®çº¦ç­‰äº0)
    card.group.position.x = 0; 
    card.group.position.z = 2; // å‰é¢ä¸€ç‚¹

    // 4. é£å‘ç›®æ ‡å¡æ§½åŠ¨ç”»
    const targetPos = CONFIG.slotPositions[STATE.currentSlot];
    const isRev = card.isReversed;
    
    let progress = 0;
    function flyAnimation() {
        progress += 0.025;
        const ease = 1 - Math.pow(1 - progress, 3);
        
        // ä½ç§»
        card.group.position.lerp(targetPos, 0.1);
        
        // æ—‹è½¬ (Yè½´ç¿»è½¬)
        card.group.rotation.y += 0.15;
        
        // ç¿»é¢
        if (!card.flipped && card.group.rotation.y > Math.PI/2) {
             if (card.textures.front) {
                card.mesh.material[0].map = card.textures.front;
                card.mesh.material[0].needsUpdate = true;
             }
             card.flipped = true;
             if (isRev) card.group.rotation.z = Math.PI;
        }

        if (progress < 1 || card.group.rotation.y < Math.PI * 2) {
            requestAnimationFrame(flyAnimation);
        } else {
            // åŠ¨ç”»ç»“æŸ
            card.group.rotation.y = 0;
            if (isRev) card.group.rotation.z = Math.PI;
            
            // è®°å½•å†å²
            addToHistory(`${SPREAD_DEFINITIONS[STATE.currentSlot].title.split('ï¼š')[1]}`, card.data.name, !isRev);
            
            // æ¨è¿›çŠ¶æ€
            STATE.currentSlot++;
            
            if (STATE.currentSlot < 3) {
                // ç»§ç»­æŠ½ä¸‹ä¸€å¼ 
                rearrangeDeckAfterDraw();
                STATE.phase = 'SCROLL';
                updateGuideText();
            } else {
                // æŠ½å®Œäº†3å¼ 
                showReadingPanel();
                STATE.phase = 'READING';
                document.getElementById('guide-text').innerText = "ä¸‰ç‰Œæ—¶é—´æµ â€¢ å‘½è¿æ˜¾ç°";
                document.getElementById('status-text').innerText = "";
            }
        }
    }
    flyAnimation();
}

function rearrangeDeckAfterDraw() {
    // é‡æ–°æ’åˆ—å‰©ä½™çš„åº•éƒ¨å¡ç‰Œï¼Œä½¿å…¶å±…ä¸­
    STATE.scrollPos = -((STATE.deckVisuals.length-1)*CONFIG.cardSpacing)/2;
    STATE.velocity = 0;
    document.getElementById('deck-count').innerText = `å‰©ä½™: ${STATE.remainingDeck.length}`;
}

function updateGuideText() {
    const texts = ["è¯·æŠ½å–ç¬¬ä¸€å¼ ï¼šè¿‡å» / æˆå› ", "è¯·æŠ½å–ç¬¬äºŒå¼ ï¼šç°åœ¨ / ç°çŠ¶", "è¯·æŠ½å–ç¬¬ä¸‰å¼ ï¼šæœªæ¥ / å‘å±•"];
    if (STATE.currentSlot < 3) {
        document.getElementById('guide-text').innerText = texts[STATE.currentSlot];
    }
}

// ==========================================
// 4. è§£è¯»ä¸ç‡ƒçƒ§
// ==========================================
function showReadingPanel() {
    const panel = document.getElementById('reading-panel');
    
    STATE.placedCards.forEach((card, i) => {
        const def = SPREAD_DEFINITIONS[i];
        const el = document.getElementById(`read-pos-${i+1}`);
        const isUp = !card.isReversed;
        
        // ç”ŸæˆåŠ¨æ€è§£è¯»æ–‡æœ¬
        const statusText = isUp ? "ã€æ­£ä½ã€‘" : "ã€é€†ä½ã€‘";
        const meaning = isUp ? card.data.up : card.data.rev;
        const advice = isUp ? def.up_desc : def.rev_desc;
        
        el.innerHTML = `
            <h3>${def.title}</h3>
            <h4>${card.data.name} ${statusText}</h4>
            <div class="pos-desc">èƒ½é‡çŠ¶æ€ï¼š${advice}</div>
            <div>${meaning}</div>
        `;
    });
    
    panel.classList.add('active');
}

function triggerBurnAll() {
    if (STATE.phase !== 'READING') return;
    STATE.phase = 'ASH';
    
    // éšè—UI
    document.getElementById('reading-panel').classList.remove('active');
    document.getElementById('guide-text').innerText = "";
    
    // å¯¹ä¸‰å¼ ç‰ŒåŒæ—¶ç”Ÿæˆç²’å­
    STATE.placedCards.forEach((card) => {
        createAsh(card.group);
        slotsGroup.remove(card.group);
    });
    STATE.placedCards = [];
}

function createAsh(obj) {
    const geo = new THREE.BufferGeometry();
    const count = 4000;
    const pos = [], spd = [];
    
    // è·å–ä¸–ç•Œåæ ‡
    const worldPos = new THREE.Vector3();
    obj.getWorldPosition(worldPos);

    for(let i=0; i<count; i++) {
        pos.push(
            worldPos.x + (Math.random()-0.5)*2,
            worldPos.y + (Math.random()-0.5)*3.5, 
            worldPos.z
        );
        spd.push(Math.random()*0.05 + 0.02);
    }
    
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    geo.setAttribute('speed', new THREE.Float32BufferAttribute(spd, 1));
    
    const mat = new THREE.PointsMaterial({
        color: 0xffffff, size: 0.05, transparent: true, opacity: 1, blending: THREE.AdditiveBlending
    });
    
    const sys = new THREE.Points(geo, mat);
    scene.add(sys);
    ashSystems.push(sys);
}

function updateAsh() {
    for (let i = ashSystems.length - 1; i >= 0; i--) {
        const sys = ashSystems[i];
        const pos = sys.geometry.attributes.position.array;
        const spd = sys.geometry.attributes.speed.array;
        
        sys.material.opacity -= 0.015;
        
        for(let j=0; j<pos.length/3; j++) {
            pos[j*3+1] += spd[j]; // Y up
            pos[j*3] += (Math.random()-0.5)*0.03;
        }
        sys.geometry.attributes.position.needsUpdate = true;
        
        if (sys.material.opacity <= 0) {
            scene.remove(sys);
            ashSystems.splice(i, 1);
            
            // å¦‚æœæ‰€æœ‰ç²’å­éƒ½æ¶ˆå¤±äº†ï¼Œé‡ç½®
            if (ashSystems.length === 0) {
                resetDeck();
            }
        }
    }
}

// å†å²è®°å½•
function addToHistory(pos, name, isUp) {
    const list = document.getElementById('history-list');
    const div = document.createElement('div');
    div.className = 'history-item';
    div.innerHTML = `
        <span style="color:#888;">[${pos}]</span> 
        ${name} 
        <span style="color:${isUp?'#4caf50':'#f44336'}">${isUp?'æ­£':'é€†'}</span>
    `;
    list.prepend(div);
}

// ==========================================
// 5. è¾“å…¥å¤„ç†
// ==========================================
let lastInputX = 0;

// é¼ æ ‡
window.addEventListener('mousedown', e => {
    if (STATE.mode!=='MOUSE') return;
    if (STATE.phase === 'SCROLL') {
        STATE.isDragging = true;
        STATE.dragStartX = (e.clientX/window.innerWidth)*2-1;
        STATE.lastInputX = STATE.dragStartX;
        STATE.velocity = 0;
    } else if (STATE.phase === 'READING') {
        triggerBurnAll();
    }
});
window.addEventListener('mousemove', e => {
    if (STATE.mode!=='MOUSE') return;
    const x = (e.clientX/window.innerWidth)*2-1;
    if (STATE.isDragging) {
        STATE.velocity = (x - STATE.lastInputX) * CONFIG.scrollSpeed;
        STATE.lastInputX = x;
    }
});
window.addEventListener('mouseup', () => {
    if (STATE.isDragging) {
        STATE.isDragging = false;
        if(Math.abs(STATE.velocity) < 0.01) confirmSelection();
    }
});

// æ‰‹åŠ¿
function onResults(res) {
    if (STATE.mode !== 'HAND' || !res.multiHandLandmarks[0]) return;
    const lm = res.multiHandLandmarks[0];
    const x = (1 - lm[8].x)*2-1;
    const isPinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05;
    const isFist = Math.hypot(lm[8].x-lm[0].x, lm[8].y-lm[0].y) < 0.25;
    
    updateGestureUI(isFist?'FIST':(isPinch?'PINCH':'OPEN'));

    if (STATE.phase === 'SCROLL') {
        if (isPinch) {
            if (!STATE.isDragging) {
                STATE.isDragging = true; STATE.dragStartX = x; STATE.lastInputX = x;
            } else {
                STATE.velocity = (x - STATE.lastInputX) * CONFIG.handSensitivity;
                STATE.lastInputX = x;
            }
        } else {
            if (STATE.isDragging) STATE.isDragging = false;
            if (isFist && Math.abs(STATE.velocity) < 0.1) confirmSelection();
        }
    } else if (STATE.phase === 'READING') {
        if (isFist) triggerBurnAll();
    }
}

// è¾…åŠ©å‡½æ•°
function updateGestureUI(txt) {
    const el = document.getElementById('gesture-indicator');
    el.innerText = txt;
    el.style.color = txt==='OPEN' ? '#aaa' : '#ffeb3b';
}
document.getElementById('btn-mode-hand').onclick = () => { STATE.mode='HAND'; document.getElementById('video-preview').style.display='block'; setupCamera(); };
document.getElementById('btn-mode-mouse').onclick = () => { STATE.mode='MOUSE'; document.getElementById('video-preview').style.display='none'; };

async function setupCamera() {
    const vid = document.getElementById('video-preview');
    const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.7});
    hands.onResults(onResults);
    const cam = new Camera(vid, {onFrame: async()=>{await hands.send({image:vid})}, width:640, height:480});
    await cam.start();
    document.getElementById('loader').style.display='none';
}

setTimeout(()=>document.getElementById('loader').style.display='none', 1000);
initThree();
</script>
</body>
</html>