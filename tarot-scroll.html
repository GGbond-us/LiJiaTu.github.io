
### ä¸»è¦ä¿®æ”¹å†…å®¹ï¼š
1.  **ç§»é™¤é‡‘è¾¹ç‰¹æ•ˆ**ï¼šåˆ é™¤äº†æ‰€æœ‰å…³äºé»„è‰²è¾¹æ¡†çš„ä»£ç ï¼Œç°åœ¨é€‰ä¸­ä»…ä¾é **å¡ç‰Œæ”¾å¤§**å’Œ**Zè½´å‡¸èµ·**æ¥ä½“ç°ï¼Œè§†è§‰æ›´çº¯å‡€ã€‚
2.  **è¡¥å…¨ 22 å¼ å¤§é˜¿å¡é‚£**ï¼šæ‰©å……äº† `TAROT_DATA` æ•°æ®ï¼ŒåŒ…å«ä» "0. æ„šè€…" åˆ° "21. ä¸–ç•Œ" çš„å®Œæ•´æ•°æ®ã€å›¾ç‰‡é“¾æ¥å’Œæ­£é€†ä½é‡Šä¹‰ã€‚
3.  **ç‰Œåº“å»é‡é€»è¾‘**ï¼š
    *   å¢åŠ äº†ä¸€ä¸ªå…¨å±€çš„ `remainingDeck` çŠ¶æ€ã€‚
    *   æ¯æ¬¡ç¡®è®¤å¹¶ç‡ƒçƒ§å¡ç‰Œåï¼Œè¯¥å¡ç‰Œä¼šä» `remainingDeck` ä¸­**æ°¸ä¹…ç§»é™¤**ã€‚
    *   ä¸‹ä¸€è½®å¼€å§‹æ—¶ï¼Œå±å¹•ä¸Šçš„å¡ç‰Œæ•°é‡ä¼šå‡å°‘ä¸€å¼ ï¼Œç›´åˆ°æ‰€æœ‰ç‰ŒæŠ½å®Œï¼ˆæ­¤æ—¶ä¼šè‡ªåŠ¨é‡ç½®ä¸ºä¸€å‰¯æ–°ç‰Œï¼‰ã€‚

### å®Œæ•´ä»£ç  (HTML)

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js å¡”ç½—å†¥æƒ³å®¤ - å®Œæ•´ç‰Œåº“ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Microsoft YaHei', sans-serif; color: #fff; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI å±‚ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        /* é¡¶éƒ¨æ§åˆ¶æ  */
        .hud-panel { position: absolute; pointer-events: auto; }
        #controls { top: 20px; left: 20px; display: flex; gap: 10px; align-items: center; }
        
        button { 
            background: rgba(0,0,0,0.6); color: #fff; 
            border: 1px solid #666; padding: 6px 15px; 
            cursor: pointer; transition: all 0.3s; 
            font-size: 12px; border-radius: 4px;
        }
        button:hover { background: #fff; color: #000; border-color: #fff; }
        button.active { background: #fff; color: #000; border-color: #fff; }
        
        /* æ‘„åƒå¤´é¢„è§ˆ */
        #video-preview { 
            width: 120px; height: 90px; transform: scaleX(-1); 
            border: 1px solid #333; display: none; margin-top: 10px; opacity: 0.8;
        }
        
        /* å†å²è®°å½•é¢æ¿ */
        #history-panel {
            position: absolute; top: 20px; right: 20px;
            width: 260px; max-height: 400px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            pointer-events: auto;
            display: flex; flex-direction: column;
            overflow-y: auto;
        }
        #history-title {
            font-size: 14px; font-weight: bold; color: #fff;
            margin-bottom: 10px; border-bottom: 1px solid #444; padding-bottom: 5px;
            display: flex; justify-content: space-between;
        }
        .history-item {
            font-size: 13px; color: #ccc; margin-bottom: 8px;
            display: flex; align-items: center; gap: 5px;
            animation: fadeIn 0.5s ease;
            border-bottom: 1px solid #222; padding-bottom: 4px;
        }
        .history-item .status { font-size: 12px; padding: 1px 4px; border-radius: 3px; margin-left: auto; }
        .history-item .up { color: #4caf50; border: 1px solid #1b5e20; }
        .history-item .rev { color: #f44336; border: 1px solid #b71c1c; }
        
        /* çŠ¶æ€æç¤º */
        #status-text { 
            position: absolute; bottom: 80px; width: 100%; text-align: center; 
            font-size: 14px; letter-spacing: 2px; opacity: 0.6; pointer-events: none; 
        }
        
        /* å¡ç‰Œå«ä¹‰å±•ç¤º */
        #card-info { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            text-align: center; width: 80%; max-width: 400px; 
            opacity: 0; transition: opacity 0.5s; pointer-events: none;
            z-index: 20;
        }
        #card-info h1 { font-size: 2rem; color: #fff; text-shadow: 0 0 15px rgba(255,255,255,0.5); margin-bottom: 5px;}
        #card-info h3 { margin: 5px 0 15px 0; color: #aaa; font-size: 1rem; font-weight: normal; }
        #card-info p { font-size: 1rem; line-height: 1.6; background: rgba(0,0,0,0.9); padding: 15px; border: 1px solid #333; border-radius: 6px; color: #ddd; }
        
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

        /* Loader */
        #loader { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            font-size: 1.2rem; color: #fff; z-index: 100; letter-spacing: 3px;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">åˆå§‹åŒ–ä¸­...</div>

    <div id="ui-layer">
        <div id="controls" class="hud-panel">
            <div style="display:flex; flex-direction:column; gap:5px;">
                <button id="btn-mode-hand">ğŸ– æ‰‹åŠ¿æ¨¡å¼</button>
                <button id="btn-mode-mouse">ğŸ–±ï¸ é¼ æ ‡æ¨¡å¼</button>
                <div id="gesture-indicator" style="font-size:12px; color:#aaa; margin-top:5px;">ç­‰å¾…ä¸­...</div>
                <video id="video-preview" playsinline></video>
            </div>
        </div>

        <div id="history-panel">
            <div id="history-title">
                <span>æŠ½å–å†å²</span>
                <span id="deck-count" style="font-weight:normal; font-size:12px; color:#888;">å‰©ä½™: 22</span>
            </div>
            <div id="history-list"></div>
        </div>

        <div id="status-text">æ»‘åŠ¨é€‰æ‹© â€¢ å±…ä¸­ç¡®è®¤</div>

        <div id="card-info">
            <h1 id="info-name">Name</h1>
            <h3 id="info-orientation">Pos</h3>
            <p id="info-desc">...</p>
        </div>
    </div>

    <div id="canvas-container"></div>

<script>
// ==========================================
// 0. å®Œæ•´å¤§é˜¿å¡é‚£æ•°æ® (22å¼ )
// ==========================================
const FULL_DECK_DATA = [
    { id: 0, name: "0. æ„šè€…", url: "https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg", up: "æ–°çš„å¼€å§‹ã€å¤©çœŸã€è‡ªç”±ç²¾ç¥", rev: "é²è½ã€è½»ç‡ã€é£é™©" },
    { id: 1, name: "I. é­”æœ¯å¸ˆ", url: "https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg", up: "åˆ›é€ åŠ›ã€æŠ€èƒ½ã€æ„å¿—åŠ›", rev: "æ¬ºéª—ã€æ‰åè¢«åŸ‹æ²¡" },
    { id: 2, name: "II. å¥³ç¥­å¸", url: "https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg", up: "ç›´è§‰ã€æ½œæ„è¯†ã€ç¥ç§˜", rev: "ç§˜å¯†æ³„éœ²ã€å‹æŠ‘æƒ…æ„Ÿ" },
    { id: 3, name: "III. çš‡å", url: "https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg", up: "ä¸°é¥¶ã€æ¯æ€§ã€è‡ªç„¶", rev: "ä¾èµ–ã€åˆ›é€ åŠ›å—é˜»" },
    { id: 4, name: "IV. çš‡å¸", url: "https://upload.wikimedia.org/wikipedia/commons/c/c3/RWS_Tarot_04_Emperor.jpg", up: "æƒå¨ã€ç»“æ„ã€ç¨³å›º", rev: "æš´æ”¿ã€åƒµåŒ–ã€å†·é…·" },
    { id: 5, name: "V. æ•™çš‡", url: "https://upload.wikimedia.org/wikipedia/commons/8/8d/RWS_Tarot_05_Hierophant.jpg", up: "ä¼ ç»Ÿã€ä¿¡ä»°ã€ç²¾ç¥æŒ‡å¼•", rev: "æŒ‘æˆ˜ä¼ ç»Ÿã€è™šä¼ªã€è¯¯å¯¼" },
    { id: 6, name: "VI. æ‹äºº", url: "https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_06_Lovers.jpg", up: "çˆ±ã€å’Œè°ã€é€‰æ‹©", rev: "åˆ†ç¦»ã€ä¸å¹³è¡¡ã€å†²çª" },
    { id: 7, name: "VII. æˆ˜è½¦", url: "https://upload.wikimedia.org/wikipedia/commons/9/9b/RWS_Tarot_07_Chariot.jpg", up: "æ§åˆ¶ã€æ„å¿—åŠ›ã€èƒœåˆ©", rev: "å¤±æ§ã€æ”»å‡»æ€§ã€å¤±è´¥" },
    { id: 8, name: "VIII. åŠ›é‡", url: "https://upload.wikimedia.org/wikipedia/commons/f/f5/RWS_Tarot_08_Strength.jpg", up: "åŠ›é‡ã€å‹‡æ°”ã€è€å¿ƒ", rev: "è½¯å¼±ã€è‡ªæˆ‘æ€€ç–‘ã€ç”Ÿç—…" },
    { id: 9, name: "IX. éšå£«", url: "https://upload.wikimedia.org/wikipedia/commons/4/4d/RWS_Tarot_09_Hermit.jpg", up: "å†…çœã€å­¤ç‹¬ã€æŒ‡å¼•", rev: "å­¤ç«‹ã€è¿·å¤±ã€æ‹’ç»å»ºè®®" },
    { id: 10, name: "X. å‘½è¿ä¹‹è½®", url: "https://upload.wikimedia.org/wikipedia/commons/3/3c/RWS_Tarot_10_Wheel_of_Fortune.jpg", up: "å¥½è¿ã€å› æœã€è½¬æŠ˜ç‚¹", rev: "å„è¿ã€æŠµæŠ—æ”¹å˜" },
    { id: 11, name: "XI. æ­£ä¹‰", url: "https://upload.wikimedia.org/wikipedia/commons/e/e0/RWS_Tarot_11_Justice.jpg", up: "æ­£ä¹‰ã€å…¬å¹³ã€çœŸç†", rev: "ä¸å…¬ã€ä¸è¯šå®ã€é€ƒé¿è´£ä»»" },
    { id: 12, name: "XII. å€’åŠäºº", url: "https://upload.wikimedia.org/wikipedia/commons/2/2b/RWS_Tarot_12_Hanged_Man.jpg", up: "ç‰ºç‰²ã€ç­‰å¾…ã€æ–°è§†è§’", rev: "æ‹–å»¶ã€æ— è°“çš„ç‰ºç‰²" },
    { id: 13, name: "XIII. æ­»ç¥", url: "https://upload.wikimedia.org/wikipedia/commons/d/d7/RWS_Tarot_13_Death.jpg", up: "ç»“æŸã€è½¬å˜ã€é‡ç”Ÿ", rev: "æŠ—æ‹’æ”¹å˜ã€åœæ»" },
    { id: 14, name: "XIV. èŠ‚åˆ¶", url: "https://upload.wikimedia.org/wikipedia/commons/f/f8/RWS_Tarot_14_Temperance.jpg", up: "å¹³è¡¡ã€é€‚åº¦ã€è€å¿ƒ", rev: "å¤±è¡¡ã€è¿‡åº¦ã€åŒ†å¿™" },
    { id: 15, name: "XV. æ¶é­”", url: "https://upload.wikimedia.org/wikipedia/commons/5/55/RWS_Tarot_15_Devil.jpg", up: "æŸç¼šã€ç‰©è´¨ä¸»ä¹‰ã€è¯±æƒ‘", rev: "æ‰“ç ´æŸç¼šã€é‡è·è‡ªç”±" },
    { id: 16, name: "XVI. é«˜å¡”", url: "https://upload.wikimedia.org/wikipedia/commons/5/53/RWS_Tarot_16_Tower.jpg", up: "çªç„¶çš„å‰§å˜ã€ç¾éš¾ã€è§‰é†’", rev: "é¿å…ç¾éš¾ã€ææƒ§æ”¹å˜" },
    { id: 17, name: "XVII. æ˜Ÿæ˜Ÿ", url: "https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_17_Star.jpg", up: "å¸Œæœ›ã€ä¿¡å¿µã€çµæ„Ÿ", rev: "ç»æœ›ã€ç¼ºä¹ä¿¡å¿ƒ" },
    { id: 18, name: "XVIII. æœˆäº®", url: "https://upload.wikimedia.org/wikipedia/commons/7/7f/RWS_Tarot_18_Moon.jpg", up: "å¹»è§‰ã€ææƒ§ã€æ½œæ„è¯†", rev: "é‡Šæ”¾ææƒ§ã€ä¸å¹¸" },
    { id: 19, name: "XIX. å¤ªé˜³", url: "https://upload.wikimedia.org/wikipedia/commons/1/17/RWS_Tarot_19_Sun.jpg", up: "å¿«ä¹ã€æˆåŠŸã€æ´»åŠ›", rev: "æ¶ˆæ²‰ã€æš‚æ—¶çš„æŒ«æŠ˜" },
    { id: 20, name: "XX. å®¡åˆ¤", url: "https://upload.wikimedia.org/wikipedia/commons/d/dd/RWS_Tarot_20_Judgement.jpg", up: "å®¡åˆ¤ã€é‡ç”Ÿã€å†…å¿ƒå¬å”¤", rev: "è‡ªæˆ‘æ€€ç–‘ã€æ‹’ç»å¬å”¤" },
    { id: 21, name: "XXI. ä¸–ç•Œ", url: "https://upload.wikimedia.org/wikipedia/commons/f/ff/RWS_Tarot_21_World.jpg", up: "å®Œæˆã€æ•´åˆã€æˆå°±", rev: "æœªå®Œæˆã€ç¼ºä¹é—­ç¯" }
];

const CONFIG = {
    cardWidth: 2.0,
    cardHeight: 3.5,
    cardRadius: 0.1,        
    cardSpacing: 3.0,       
    scrollSpeed: 4.0,       
    friction: 0.92,         
    snapStrength: 0.08,     
    handSensitivity: 8.0
};

const STATE = {
    mode: 'HAND', 
    phase: 'SCROLL',        // SCROLL -> REVEAL -> WAIT_BURN -> ASH
    scrollPos: 0,
    velocity: 0,
    isDragging: false,
    lastInputX: 0,
    selectedIndex: 0,
    
    // ç‰Œåº“é€»è¾‘
    remainingDeck: [...FULL_DECK_DATA], // å‰©ä½™å¡ç‰Œ
    currentVisualCards: [] // å½“å‰åœºæ™¯ä¸­çš„å¡ç‰Œå¯¹è±¡å¼•ç”¨
};

// ==========================================
// 1. å‡ ä½•ä½“ç”Ÿæˆ
// ==========================================
function createRoundedCardGeometry(width, height, radius) {
    const shape = new THREE.Shape();
    const x = -width / 2;
    const y = -height / 2;
    
    shape.moveTo(x + radius, y);
    shape.lineTo(x + width - radius, y);
    shape.quadraticCurveTo(x + width, y, x + width, y + radius);
    shape.lineTo(x + width, y + height - radius);
    shape.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    shape.lineTo(x + radius, y + height);
    shape.quadraticCurveTo(x, y + height, x, y + height - radius);
    shape.lineTo(x, y + radius);
    shape.quadraticCurveTo(x, y, x + radius, y);

    const geometry = new THREE.ExtrudeGeometry(shape, {
        depth: 0.02, 
        bevelEnabled: false,
        curveSegments: 12
    });

    geometry.computeBoundingBox();
    const min = geometry.boundingBox.min;
    const max = geometry.boundingBox.max;
    const range = new THREE.Vector2(max.x - min.x, max.y - min.y);
    const uvAttribute = geometry.attributes.uv;
    const posAttribute = geometry.attributes.position;
    
    for (let i = 0; i < posAttribute.count; i++) {
        const x = posAttribute.getX(i);
        const y = posAttribute.getY(i);
        uvAttribute.setXY(i, (x - min.x) / range.x, (y - min.y) / range.y);
    }
    geometry.center();
    return geometry;
}

function createCardBackTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 800;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,512,800);
    // æç®€ç°æ¡†
    ctx.strokeStyle = '#f0f0f0'; ctx.lineWidth = 10; ctx.strokeRect(10,10,492,780);
    return new THREE.CanvasTexture(canvas);
}

// ==========================================
// 2. Three.js åˆå§‹åŒ–
// ==========================================
let scene, camera, renderer;
let cardGroup = new THREE.Group();
let ashSystem = null;
let mouse = new THREE.Vector2();

// å¤ç”¨å‡ ä½•ä½“
const sharedGeometry = createRoundedCardGeometry(CONFIG.cardWidth, CONFIG.cardHeight, CONFIG.cardRadius);

function initThree() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); 

    camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 14); 

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(2, 5, 5);
    scene.add(dirLight);

    scene.add(cardGroup);
    
    // åˆå§‹æ´—ç‰Œ
    shuffleDeck(STATE.remainingDeck);
    createVisualDeck();

    window.addEventListener('resize', onWindowResize);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mousedown', onMouseDown);
    document.addEventListener('mouseup', onMouseUp);

    animate();
}

// æ´—ç‰Œç®—æ³•
function shuffleDeck(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

// æ ¹æ® remainingDeck ç”Ÿæˆåœºæ™¯ç‰©ä½“
function createVisualDeck() {
    // æ¸…ç†æ—§çš„ Mesh
    while(cardGroup.children.length > 0){ 
        cardGroup.remove(cardGroup.children[0]); 
    }
    STATE.currentVisualCards = [];

    // å¦‚æœç‰ŒæŠ½å®Œäº†ï¼Œè‡ªåŠ¨é‡ç½®ä¸€æ•´å‰¯
    if (STATE.remainingDeck.length === 0) {
        STATE.remainingDeck = [...FULL_DECK_DATA];
        shuffleDeck(STATE.remainingDeck);
        // æ¸…ç©ºå†å²ï¼ˆå¯é€‰ï¼‰
        // document.getElementById('history-list').innerHTML = '';
        addToHistory("--- æ´—ç‰Œ (Reshuffle) ---", true, true);
    }
    
    // æ›´æ–°å‰©ä½™æ•°é‡UI
    document.getElementById('deck-count').innerText = `å‰©ä½™: ${STATE.remainingDeck.length}`;

    const backTex = createCardBackTexture();
    
    // éå†å‰©ä½™çš„ç‰Œåº“ç”Ÿæˆæ¨¡å‹
    STATE.remainingDeck.forEach((data, i) => {
        // å¡ç‰Œ Mesh
        const cardMat = new THREE.MeshStandardMaterial({ 
            map: backTex, 
            roughness: 0.6, metalness: 0.1
        });
        const sideMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
        const mesh = new THREE.Mesh(sharedGeometry, [cardMat, sideMat]);

        // ç»„åˆï¼ˆæ–¹ä¾¿åç»­åšç¿»è½¬åŠ¨ç”»ï¼‰
        const group = new THREE.Group();
        group.add(mesh);
        
        // æ’åˆ—ä½ç½®
        group.position.set(i * CONFIG.cardSpacing, 0, 0);
        
        // æ•°æ®ç»‘å®š
        const cardObj = {
            group: group,
            mesh: mesh,
            data: data,
            isReversed: Math.random() < 0.5, // æŠ½çš„æ—¶å€™éšæœºå®šæ­£é€†ä½
            textures: { back: backTex, front: null },
            flipped: false
        };
        
        // é¢„åŠ è½½æ­£é¢å›¾
        new THREE.TextureLoader().load(data.url, (tex) => {
            cardObj.textures.front = tex;
        });

        cardGroup.add(group);
        STATE.currentVisualCards.push(cardObj);
    });
    
    // æ»šåŠ¨æ¡å¤ä½åˆ°ä¸­é—´
    STATE.scrollPos = -((STATE.remainingDeck.length - 1) * CONFIG.cardSpacing) / 2;
    STATE.phase = 'SCROLL';
    updateStatusText("æ»‘åŠ¨é€‰æ‹© â€¢ å±…ä¸­ç¡®è®¤");
}

// ==========================================
// 3. é€»è¾‘ä¸è§†è§‰
// ==========================================
function updatePhysics() {
    if (STATE.phase !== 'SCROLL') return;

    if (STATE.isDragging) {
        STATE.velocity = (STATE.lastInputX - STATE.dragStartX) * CONFIG.scrollSpeed;
    } 
    STATE.scrollPos += STATE.velocity;

    if (!STATE.isDragging) {
        STATE.velocity *= CONFIG.friction;
        
        const cardCount = STATE.currentVisualCards.length;
        if (cardCount === 0) return;

        const minScroll = -((cardCount - 1) * CONFIG.cardSpacing);
        
        if (STATE.scrollPos > 0) STATE.velocity += (0 - STATE.scrollPos) * 0.1;
        else if (STATE.scrollPos < minScroll) STATE.velocity += (minScroll - STATE.scrollPos) * 0.1;
        else if (Math.abs(STATE.velocity) < 0.05) {
            const idx = Math.round(-STATE.scrollPos / CONFIG.cardSpacing);
            const target = -idx * CONFIG.cardSpacing;
            STATE.scrollPos += (target - STATE.scrollPos) * CONFIG.snapStrength;
            STATE.velocity *= 0.5;
            STATE.selectedIndex = Math.max(0, Math.min(cardCount-1, idx));
        }
    }
}

function updateVisuals() {
    if (STATE.phase !== 'SCROLL') return;

    STATE.currentVisualCards.forEach((card, i) => {
        const targetX = i * CONFIG.cardSpacing + STATE.scrollPos;
        card.group.position.x = targetX;
        
        const dist = Math.abs(targetX);
        
        // ç¼©æ”¾é€»è¾‘ (ä¸­å¿ƒå¤§ï¼Œä¸¤è¾¹å°)
        const scale = 1 + 0.15 * Math.exp(-(dist*dist)/2);
        card.group.scale.set(scale, scale, scale);
        
        // Zè½´é€»è¾‘ (ä¸­å¿ƒå‡¸èµ·)
        card.group.position.z = 2 - dist * 0.5;

        // ã€å·²ç§»é™¤é‡‘è¾¹é€»è¾‘ã€‘é€‰ä¸­ä»…é  ç¼©æ”¾ + ä½ç½® åŒºåˆ†
    });
}

// å†å²è®°å½•
function addToHistory(name, isUp, isSystem = false) {
    const list = document.getElementById('history-list');
    const div = document.createElement('div');
    div.className = 'history-item';
    
    if (isSystem) {
        div.innerHTML = `<span style="color:#888; width:100%; text-align:center;">${name}</span>`;
    } else {
        div.innerHTML = `<span>Â· ${name}</span><span class="status ${isUp?'up':'rev'}">${isUp?'æ­£':'é€†'}</span>`;
    }
    list.prepend(div);
}

// ==========================================
// 4. äº¤äº’æµç¨‹
// ==========================================
function confirmSelection() {
    if (STATE.phase !== 'SCROLL' || Math.abs(STATE.velocity) > 0.1) return;
    
    const card = STATE.currentVisualCards[STATE.selectedIndex];
    if (!card) return;

    STATE.phase = 'REVEAL';
    updateStatusText("å‘½è¿æ˜¾ç°...");

    // éšè—å…¶ä»–å¡ç‰Œ
    STATE.currentVisualCards.forEach((c, i) => {
        if (i !== STATE.selectedIndex) c.group.visible = false;
    });

    // ç¿»ç‰ŒåŠ¨ç”»
    const isRev = card.isReversed;
    let progress = 0;
    
    function animateReveal() {
        progress += 0.03;
        
        card.group.position.lerp(new THREE.Vector3(0, 0, 8), 0.1);
        card.group.rotation.y += 0.15;

        if (!card.flipped && card.group.rotation.y > Math.PI/2) {
            if (card.textures.front) {
                card.mesh.material[0].map = card.textures.front;
                card.mesh.material[0].needsUpdate = true;
            }
            card.flipped = true;
            if (isRev) card.group.rotation.z = Math.PI;
        }

        if (progress < 1 || card.group.rotation.y < Math.PI * 2) {
             requestAnimationFrame(animateReveal);
        } else {
            card.group.rotation.y = 0;
            if (isRev) card.group.rotation.z = Math.PI;
            
            showUIInfo(card);
            STATE.phase = 'WAIT_BURN'; 
            updateStatusText("å†æ¬¡ç‚¹å‡»å¡ç‰Œ æˆ– æ¡æ‹³ -> åŒ–ä¸ºç°çƒ¬");
        }
    }
    animateReveal();
}

function showUIInfo(card) {
    document.getElementById('info-name').innerText = card.data.name;
    document.getElementById('info-orientation').innerText = card.isReversed ? "é€†ä½" : "æ­£ä½";
    document.getElementById('info-orientation').style.color = card.isReversed ? "#ff6b6b" : "#4caf50";
    document.getElementById('info-desc').innerText = card.isReversed ? card.data.rev : card.data.up;
    document.getElementById('card-info').style.opacity = 1;
    
    // å†™å…¥å†å²
    addToHistory(card.data.name, !card.isReversed);
}

// è§¦å‘ç‡ƒçƒ§
function triggerAsh() {
    if (STATE.phase !== 'WAIT_BURN') return;
    
    STATE.phase = 'ASH';
    const card = STATE.currentVisualCards[STATE.selectedIndex];
    
    // ä»ç‰Œåº“æ•°æ®ä¸­ç§»é™¤è¯¥ç‰Œ
    const removeId = card.data.id;
    STATE.remainingDeck = STATE.remainingDeck.filter(c => c.id !== removeId);

    // 1. åˆ›å»ºçº¯ç™½ç²’å­
    const geo = new THREE.BufferGeometry();
    const count = 5000;
    const pos = [];
    const spd = [];
    
    for(let i=0; i<count; i++) {
        pos.push((Math.random()-0.5)*2.2, (Math.random()-0.5)*3.8, 0);
        spd.push(Math.random()*0.04 + 0.01);
    }
    
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    geo.setAttribute('speed', new THREE.Float32BufferAttribute(spd, 1));
    
    const mat = new THREE.PointsMaterial({
        color: 0xffffff, 
        size: 0.04, 
        transparent: true, 
        opacity: 1,
        blending: THREE.AdditiveBlending 
    });
    
    ashSystem = new THREE.Points(geo, mat);
    ashSystem.position.copy(card.group.position);
    ashSystem.rotation.copy(card.group.rotation);
    scene.add(ashSystem);
    
    // 2. ç§»é™¤å¡ç‰Œå®ä½“
    scene.remove(card.group); 
    cardGroup.remove(card.group); 

    // 3. éšè— UI
    document.getElementById('card-info').style.opacity = 0;
    updateStatusText("...");
}

function updateAsh() {
    if (!ashSystem) return;
    
    const pos = ashSystem.geometry.attributes.position.array;
    const spd = ashSystem.geometry.attributes.speed.array;
    
    ashSystem.material.opacity -= 0.01; 
    
    for(let i=0; i<pos.length/3; i++) {
        pos[i*3+1] += spd[i]; 
        pos[i*3] += (Math.random()-0.5)*0.02;
        pos[i*3+2] += (Math.random()-0.5)*0.02; 
    }
    ashSystem.geometry.attributes.position.needsUpdate = true;
    
    if (ashSystem.material.opacity <= 0) {
        scene.remove(ashSystem);
        ashSystem = null;
        // åŠ¨ç”»ç»“æŸåï¼Œæ ¹æ®å‰©ä½™ç‰Œåº“é‡ç»˜åœºæ™¯
        createVisualDeck();
    }
}

function updateStatusText(txt) {
    document.getElementById('status-text').innerText = txt;
}

// ==========================================
// 5. è¾“å…¥å¤„ç†
// ==========================================
function onMouseDown(e) {
    if(STATE.mode !== 'MOUSE') return;
    
    if(STATE.phase === 'SCROLL') {
        STATE.isDragging = true;
        STATE.dragStartX = (e.clientX / window.innerWidth) * 2 - 1;
        STATE.lastInputX = STATE.dragStartX;
        STATE.velocity = 0; 
    } else if (STATE.phase === 'WAIT_BURN') {
        triggerAsh(); 
    }
}

function onMouseMove(e) {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    if(STATE.isDragging && STATE.mode === 'MOUSE') {
        const x = (e.clientX / window.innerWidth) * 2 - 1;
        STATE.velocity = (x - STATE.lastInputX) * CONFIG.scrollSpeed;
        STATE.lastInputX = x;
    }
}

function onMouseUp() {
    if(STATE.isDragging) {
        STATE.isDragging = false;
        if(Math.abs(STATE.velocity) < 0.01) confirmSelection();
    }
}

// MediaPipe Hands
function onResults(results) {
    if (STATE.mode !== 'HAND' || !results.multiHandLandmarks[0]) return;
    const lm = results.multiHandLandmarks[0];
    const x = (1 - lm[8].x) * 2 - 1;
    
    const isPinch = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y) < 0.05;
    const isFist = Math.hypot(lm[8].x-lm[0].x, lm[8].y-lm[0].y) < 0.3;
    
    updateGestureUI(isFist ? 'FIST' : (isPinch ? 'PINCH' : 'OPEN'));

    if (STATE.phase === 'SCROLL') {
        if (isPinch) {
            if (!STATE.isDragging) {
                STATE.isDragging = true; STATE.dragStartX = x; STATE.lastInputX = x;
            } else {
                STATE.velocity = (x - STATE.lastInputX) * CONFIG.handSensitivity;
                STATE.lastInputX = x;
            }
        } else {
            if (STATE.isDragging) STATE.isDragging = false;
            if (isFist && Math.abs(STATE.velocity) < 0.1) confirmSelection();
        }
    } else if (STATE.phase === 'WAIT_BURN') {
        if (isFist) triggerAsh();
    }
}

function updateGestureUI(txt) {
    const el = document.getElementById('gesture-indicator');
    el.innerText = txt;
    el.style.color = txt === 'OPEN' ? '#aaa' : '#ffeb3b';
}

function onWindowResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

document.getElementById('btn-mode-hand').onclick = () => {
    STATE.mode = 'HAND'; document.getElementById('video-preview').style.display='block';
    setupCamera();
};
document.getElementById('btn-mode-mouse').onclick = () => {
    STATE.mode = 'MOUSE'; document.getElementById('video-preview').style.display='none';
};

async function setupCamera() {
    const video = document.getElementById('video-preview');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.7});
    hands.onResults(onResults);
    const camera = new Camera(video, { onFrame: async () => await hands.send({image: video}), width: 640, height: 480 });
    await camera.start();
    document.getElementById('loader').style.display = 'none';
}

function animate() {
    requestAnimationFrame(animate);
    updatePhysics();
    updateVisuals();
    updateAsh(); 
    renderer.render(scene, camera);
}

setTimeout(()=>document.getElementById('loader').style.display='none', 1000);
initThree();
</script>
</body>
</html>
